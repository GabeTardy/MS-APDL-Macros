! Maple-Configured Sinusoidal Snapthrough
! Written by Gabriel Tardy, July 2025
! Prerequisites:
! Snap2DMaple.mw (Maple file)
! rs.mac (+viridis2.cmap)
! bimodulus.mac
! sinarc.mac
! sinloadbeam.mac
! view.mac

!!- Setup
rs

! Load geometry data
/inquire,numConstants,lines,'Snap2DGeom','csv'
*dim,Snap2DGeom,table,numConstants,1
*tread,Snap2DGeom,'Snap2DGeom','csv',,0

! Load load data
/inquire,numLoadSteps,lines,'Snap2DLoading','csv'
numLoadSteps = numLoadSteps - 1 ! True number of load steps does not include first load of 0 at time = 0
*dim,LoadSteps,table,numLoadSteps,2
*tread,LoadSteps,'Snap2DLoading','csv',,0

/pbc,all,,1 ! Show boundary conditions
/hbc,all,on ! Use improved rendering for hidden boundary conditions
/psf,pres,norm,2,1,on ! Show pressures on model (normal)
/eshape,1 ! show true cross-sections
view,snap ! Use my view macro to move the simulated camera to view the negative z-axis

fps = 60 ! Frames per second for the animation

! Acquire data from the generated Snap2DGeom.csv file (containing geometry, setup, system data)
l           = Snap2DGeom(1)
h           = Snap2DGeom(2)
b           = Snap2DGeom(3)
a0          = Snap2DGeom(4)
E1          = Snap2DGeom(5)
rho         = Snap2DGeom(6)
prxy        = Snap2DGeom(7)
omega_      = Snap2DGeom(8)
alphad      = Snap2DGeom(9)
isbimodulus = Snap2DGeom(10)
E2          = Snap2DGeom(11)
beta        = Snap2DGeom(12)
q0          = Snap2DGeom(13)
anFlags     = Snap2DGeom(14)
! anFlags is a bitmask containing various flags:
! Bit 0 (1): Generate static solution
! Bit 1 (2): Generate transient solution
! Bit 2+ (4+): Reserved for future use

*if,BTEST(anFlags,0),eq,0,and,BTEST(anFlags,1),eq,0,then
    *msg,error,''
No solution flags set. At least one solution is required.
    rs
    /eof ! stop the rest of the macro from executing
*endif

kPeriod = 5 !*(isbimodulus/2+1) ! Multiplier for the natural frequency; higher k gives better results at the cost of longer simulation time. We multiply the value by isBimodulus so that if the bimodulus model is used, more iterations are also used.

! Set the number of divisions for the sine arc
ndiv = 20

! ---------- PREPROCESSOR ---------- !
/prep7 ! Enter preprocessor

! Define section properties for the beam
et,1,189
sectype,1,beam,rect
secdata,b,h

! Define material properties for the beam
*if,isbimodulus,eq,0,then ! Unimodulus properties
    mp,ex,1,E1
    mp,prxy,1,prxy
*else ! Bimodulus properties
    bimodulus,E1,E2,prxy,prxy,isbimodulus,beta
*endif
mp,dens,1,rho

! Set a lower selection tolerance so that if a large number of elements are used, the right boundary conditions are still picked
seltol,0.001

! Create a sine arc, l units long with ndiv divisions and a0 height in the -z-direction
sinarc,l,ndiv,a0,2

! Mesh the beam with 1-unit elements.
lesize,all,,,1
lmesh,all

! Apply pin-pin boundary conditions
d,NODE(0,0,0),ux,0,,,,uy,uz,rotx,rotz
d,NODE(l,0,0),ux,0,,,,uy,uz,rotx,rotz

! ---------- STATIC SOLUTION ---------- !
*if,BTEST(anFlags,0),eq,1,then ! Check if first bit is set (implies static solution)
    finish ! Close any previous processor
    /solu ! Enter solution processor
    antype,static ! Set static analysis
    nlgeom,on ! Set geometric nonlinearities on
    nsubst,50 ! Use 50 substeps minimum
    arclen,on,1 ! Turn on arc length method/set a maximum radius
    outres,all,all ! Make sure all data is outputted
    outres,svar,all ! REALLY all data, this time.

    ! Appy maximum static load
    sinloadbeam,q0,l,2
    solve

    ! Send data back to Maple (Static)
    /post26
    nsol,2,NODE(L/2, 0, a0),u,z
    plvar,2

    ! Place the time and displacement data into new variables
    vget,time,1
    vget,dz,2

    ! Open the output file, write the data, then close the output file
    *cfopen,'Snap2DOutputStatic','csv'
    *vwrite,time(1),dz(1)
    %G,%G
    *cfclos
*endif

! ---------- TRANSIENT SOLUTION ---------- !
*if,BTEST(anFlags,1),eq,1,then ! Check if second bit is set (implies transient solution)
    finish ! Close any previous processor
    /solu ! Enter solution processor
    lsclear,all ! Delete all static loads
    lsdele,all ! Delete all load steps

    ! Reapply pin-pin boundary conditions
    d,NODE(0,0,0),ux,0,,,,uy,uz,rotx,rotz
    d,NODE(l,0,0),ux,0,,,,uy,uz,rotx,rotz

    antype,transient ! Set dynamic analysis
    arclen,off
    nlgeom,on ! Set geometric nonlinearities on
    deltim,1/(kPeriod*omega_) ! Set time step size based on the natural frequency and kPeriod multiplier
    alphad,alphad ! Set the mass damping ratio
    betad,0 ! Set the stiffness damping ratio
    kbc,0 ! Set ramped loading
    lumpm,0 ! Do not use the lumped mass approximation
    outres,all,all ! Make sure all data is outputted
    outres,svar,all ! REALLY all data, this time.
    ncnv,0 ! Do not stop executing solution and wait for convergence

    ! Iterate over all load steps:
    *do,ii,1,numLoadSteps
        ! - Applying loading
        sinloadbeam,LoadSteps(ii,2),l,2

        ! - At a certain time
        time,LoadSteps(ii,1)

        ! - Write to the load step file
        lswrite,ii

        ! - Update the interface with the loading
        *msg,ui,ii,numLoadSteps
    Number of load steps inputted: %I of %G
    *enddo

    ! Update the interface predicting the amount of time (the variable) the simulation will take
    *msg,ui,LoadSteps(numLoadSteps,1)
    Total Expected TIME: %g

    ! Solve all load steps
    lssolve,1,numLoadSteps,1

    ! Send data back to Maple
    finish
    /post26
    nsol,3,NODE(L/2, 0, a0),u,z
    plvar,3

    ! Place the time and displacement data into new variables
    vget,time2,1
    vget,dz2,3

    ! Open the output file, write the data, then close the output file
    *cfopen,'Snap2DOutputTransient','csv'
    *vwrite,time2(1),dz2(1)
    %G,%G
    *cfclos
*endif

! Create an animation (only visible in non-batch mode)
/post1
eplot
/gline,all,-1 ! Remove element outlines (for sanity reasons)
set,last
view,snap ! Make sure that the view is in the right orientation
view,side ! DEBUG

! Plot stress in x-direction
plns,s,x,0,1

! Calculate total number of frames required (the real time of the last load step multiplied by the number of frames per second, rounded down)
numFrames = NINT(LoadSteps(numLoadSteps,1)*fps)

! Export avi (required)
/seg,singl,Snap,1/fps

! Create an animation of the previously displayed data
antime,numFrames,1/fps,,1,1,1,numLoadSteps

! Make sure that the animation plays forward only
anim,,1,1/fps

! Save the database file
save